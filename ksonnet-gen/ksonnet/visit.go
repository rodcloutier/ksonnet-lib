package ksonnet

import (
	"bytes"
	"fmt"
	"log"
	"strings"

	"github.com/ksonnet/ksonnet-lib/ksonnet-gen/jsonnet"
	"github.com/ksonnet/ksonnet-lib/ksonnet-gen/kubespec"
)

// Visitor is the interface for a Ksonnet gen visitor
type Visitor interface {
	visitRoot(root *root)
	visitGroup(group *group, hidden bool)
	visitVersionedAPI(va *versionedAPI)
	visitComments(cs *comments)

	visitAPIObject(ao *apiObject)
	visitRefMixinAPIObject(rmao *refMixinAPIObject, parentMixinName *string)

	visitConstructor(c *constructor)
	visitProperty(p *property, parentMixinName *string)
	visitTypeAlias(p *property)
	visitRefProperty(p *property, parentMixinName *string)
}

type emitVisitor struct {
	groups        indentWriter
	hiddenGroups  indentWriter
	indentWriters map[interface{}]*indentWriter
}

func newEmitVisitor() *emitVisitor {
	e := emitVisitor{
		indentWriters: make(map[interface{}]*indentWriter),
	}
	return &e
}

func (e *emitVisitor) write(src interface{}) ([]byte, error) {
	i := e.indentWriters[src]
	// TODO check that we indeed have one!
	var buffer bytes.Buffer

	err := i.write(&buffer)
	if err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}

func (e *emitVisitor) visitRoot(root *root) {

	i := indentWriter{}
	e.indentWriters[root] = &i

	i.writeLine("// AUTOGENERATED from the Kubernetes OpenAPI specification. DO NOT MODIFY.")
	i.writeLine(fmt.Sprintf("// Kubernetes version: %s", root.spec.Info.Version))

	if root.ksonnetLibSHA != nil {
		i.writeLine(fmt.Sprintf(
			"// SHA of ksonnet-lib HEAD: %s", *root.ksonnetLibSHA))
	}

	if root.ksonnetLibSHA != nil {
		i.writeLine(fmt.Sprintf(
			"// SHA of Kubernetes HEAD OpenAPI spec is generated from: %s",
			*root.k8sSHA))
	}
	i.writeLine("")

	i.writeLine("{")
	i.indent()

	i.insert(e.groups)

	i.writeLine("local hidden = {")
	i.indent()

	i.insert(e.hiddenGroups)

	i.dedent()
	i.writeLine("},")

	i.dedent()
	i.writeLine("}")
}

func (e *emitVisitor) visitGroup(group *group, hidden bool) {

	i := &e.groups
	if hidden {
		i = &e.hiddenGroups
	}

	k8sVersion := group.root().spec.Info.Version
	mixinName := jsonnet.RewriteAsIdentifier(k8sVersion, group.name)
	line := fmt.Sprintf("%s:: {", mixinName)

	i.writeLine(line)
	i.indent()

	for _, versioned := range group.versionedAPIs.toSortedSlice() {
		i.insert(*e.indentWriters[versioned])
	}

	i.dedent()
	i.writeLine("},")
}

func (e *emitVisitor) visitVersionedAPI(va *versionedAPI) {

	i := indentWriter{}
	e.indentWriters[va] = &i

	// NOTE: Do not need to call `jsonnet.RewriteAsIdentifier`.
	line := fmt.Sprintf("%s:: {", va.version)
	i.writeLine(line)
	i.indent()

	gn := va.parent.qualifiedName
	if gn == "core" {
		i.writeLine(fmt.Sprintf(
			"local apiVersion = {apiVersion: \"%s\"},", va.version))
	} else {
		i.writeLine(fmt.Sprintf(
			"local apiVersion = {apiVersion: \"%s/%s\"},", gn, va.version))
	}

	// Emit in sorted order so that we can diff the output.
	for _, object := range va.apiObjects.toSortedSlice() {
		i.insert(*e.indentWriters[object])
	}

	i.dedent()
	i.writeLine("},")
}

func (e *emitVisitor) visitAPIObject(ao *apiObject) {

	i := indentWriter{}
	e.indentWriters[ao] = &i

	k8sVersion := ao.root().spec.Info.Version
	jsonnetName := kubespec.ObjectKind(jsonnet.RewriteAsIdentifier(k8sVersion, ao.name))

	i.insert(*e.indentWriters[&ao.comments])

	i.writeLine(fmt.Sprintf("%s:: {", jsonnetName))
	i.indent()

	if ao.isTopLevel {
		// NOTE: It is important to NOT capitalize `ao.name` here.
		i.writeLine(fmt.Sprintf("local kind = {kind: \"%s\"},", ao.name))
	}

	for _, constructor := range ao.constructors {
		i.insert(*e.indentWriters[constructor])
	}

	for _, pm := range ao.properties.sortAndFilterBlacklisted() {
		if isSpecialProperty(pm.name) || isMixinRef(pm.ref) {
			continue
		}
		i.insert(*e.indentWriters[pm])
	}

	// Emit the properties that `$ref` another API object type in the
	// `mixin:: {` namespace.
	i.writeLine("mixin:: {")
	i.indent()

	for _, pm := range ao.properties.sortAndFilterBlacklisted() {
		// TODO: Emit mixin code also for arrays whose elements are
		// `$ref`.
		if !isMixinRef(pm.ref) {
			continue
		}

		i.insert(*e.indentWriters[pm])
	}

	i.dedent()
	i.writeLine("},")

	i.dedent()
	i.writeLine("},")
}

func (e *emitVisitor) visitRefMixinAPIObject(rmao *refMixinAPIObject, parentMixinName *string) {

	p := rmao.prop

	i := indentWriter{}
	e.indentWriters[p] = &i

	k8sVersion := rmao.root().spec.Info.Version
	functionName := jsonnet.RewriteAsIdentifier(k8sVersion, p.name)
	paramName := jsonnet.RewriteAsFuncParam(k8sVersion, p.name)
	fieldName := jsonnet.RewriteAsFieldKey(p.name)
	mixinName := fmt.Sprintf("__%sMixin", functionName)
	var mixinText string
	if parentMixinName == nil {
		mixinText = fmt.Sprintf(
			"local %s(%s) = {%s+: %s},", mixinName, paramName, fieldName, paramName)
	} else {
		mixinText = fmt.Sprintf(
			"local %s(%s) = %s({%s+: %s}),",
			mixinName, paramName, *parentMixinName, fieldName, paramName)
	}

	if _, ok := rmao.parent.apiObjects[kubespec.ObjectKind(functionName)]; ok {
		log.Panicf(
			"Tried to lowercase first character of object kind '%s', but lowercase name was already present in version '%s'",
			functionName,
			rmao.parent.version)
	}

	// NOTE: Comments are emitted by `property#emit`, before we
	// call this method.
	i.insert(*e.indentWriters[&p.comments])

	line := fmt.Sprintf("%s:: {", functionName)
	i.writeLine(line)
	i.indent()

	i.writeLine(mixinText)
	i.writeLine(fmt.Sprintf("mixinInstance(%s):: %s(%s),", paramName, mixinName, paramName))

	for _, pm := range rmao.properties.sortAndFilterBlacklisted() {
		if pi, ok := e.indentWriters[pm]; ok {
			i.insert(*pi)
		}
	}

	i.dedent()
	i.writeLine("},")
}

func (e *emitVisitor) visitConstructor(c *constructor) {
	// Build parameters and body of constructor. Considering the example
	// of the constructor of `v1.Container`:
	//
	//   new(name, image):: self.name(name) + self.image(image),
	//
	// Here we want to (1) assemble the parameter list (i.e., `name` and
	// `image`), as well as the body (i.e., the calls to `self.name` and
	// so on).
	paramLiterals := []string{}
	setters := c.defaultSetters
	for _, param := range c.params {
		// Add the param to the param list, including default value if
		// applicable.
		if param.DefaultValue != nil {
			paramLiterals = append(
				paramLiterals, fmt.Sprintf("%s=%s", param.ID, *param.DefaultValue))
		} else {
			paramLiterals = append(paramLiterals, param.ID)
		}

		// Add an element to the body (e.g., `self.name` above).
		if param.RelativePath == nil {
			prop, ok := c.apiObj.properties[kubespec.PropertyName(param.ID)]
			if !ok {
				log.Panicf(
					"Attempted to create constructor, but property '%s' does not exist",
					param.ID)
			}
			k8sVersion := c.apiObj.root().spec.Info.Version
			propMethodName := jsonnet.RewriteAsIdentifier(k8sVersion, prop.name).ToSetterID()
			setters = append(
				setters, fmt.Sprintf("self.%s(%s)", propMethodName, param.ID))
		} else {
			// TODO(hausdorff): We may want to verify this relative path
			// exists.
			setters = append(
				setters, fmt.Sprintf("self.%s(%s)", *param.RelativePath, param.ID))
		}
	}

	// Write out constructor.
	paramsText := strings.Join(paramLiterals, ", ")
	bodyText := strings.Join(setters, " + ")
	i := indentWriter{}
	e.indentWriters[c] = &i
	i.writeLine(fmt.Sprintf("%s(%s):: %s,", c.specName, paramsText, bodyText))
}

func (e *emitVisitor) visitProperty(p *property, parentMixinName *string) {

	i := indentWriter{}
	e.indentWriters[p] = &i

	paramType := *p.schemaType

	k8sVersion := p.root().spec.Info.Version
	setterFunctionName := jsonnet.RewriteAsIdentifier(k8sVersion, p.name).ToSetterID()
	paramName := jsonnet.RewriteAsFuncParam(k8sVersion, p.name)
	fieldName := jsonnet.RewriteAsFieldKey(p.name)

	//
	// Generate both setter and mixin functions for some property. For
	// example, we emit both `metadata.setAnnotations({foo: "bar"})`
	// (which replaces a set of annotations with given object) and
	// `metadata.mixinAnnotations({foo: "bar"})` (which replaces only
	// the `foo` key, if it exists.)
	//

	var setterBody string
	var mixinBody string
	emitMixin := false
	switch paramType {
	case "array":
		emitMixin = true
		if parentMixinName == nil {
			setterBody = fmt.Sprintf(
				"if std.type(%s) == \"array\" then {%s: %s} else {%s: [%s]}",
				paramName, fieldName, paramName, fieldName, paramName,
			)
			mixinBody = fmt.Sprintf(
				"if std.type(%s) == \"array\" then {%s+: %s} else {%s+: [%s]}",
				paramName, fieldName, paramName, fieldName, paramName,
			)
		} else {
			setterBody = fmt.Sprintf(
				"if std.type(%s) == \"array\" then %s({%s: %s}) else %s({%s: [%s]})",
				paramName, *parentMixinName, fieldName, paramName, *parentMixinName,
				fieldName, paramName,
			)
			mixinBody = fmt.Sprintf(
				"if std.type(%s) == \"array\" then %s({%s+: %s}) else %s({%s+: [%s]})",
				paramName, *parentMixinName, fieldName, paramName, *parentMixinName,
				fieldName, paramName,
			)
		}
	case "integer", "string", "boolean":
		if parentMixinName == nil {
			setterBody = fmt.Sprintf("{%s: %s}", fieldName, paramName)
		} else {
			setterBody = fmt.Sprintf("%s({%s: %s})", *parentMixinName, fieldName, paramName)
		}
	case "object":
		emitMixin = true
		if parentMixinName == nil {
			setterBody = fmt.Sprintf("{%s: %s}", fieldName, paramName)
			mixinBody = fmt.Sprintf("{%s+: %s}", fieldName, paramName)
		} else {
			setterBody = fmt.Sprintf("%s({%s: %s})", *parentMixinName, fieldName, paramName)
			mixinBody = fmt.Sprintf("%s({%s+: %s})", *parentMixinName, fieldName, paramName)
		}
	default:
		log.Panicf("Unrecognized type '%s'", paramType)
	}

	//
	// Emit.
	//
	i.insert(*e.indentWriters[&p.comments])

	setterSignature := fmt.Sprintf("%s(%s)::", setterFunctionName, paramName)
	line := fmt.Sprintf("%s self + %s,", setterSignature, setterBody)
	i.writeLine(line)

	if emitMixin {
		i.insert(*e.indentWriters[&p.comments])
		mixinFunctionName := jsonnet.RewriteAsIdentifier(k8sVersion, p.name).ToMixinID()
		mixinSignature := fmt.Sprintf("%s(%s)::", mixinFunctionName, paramName)
		line = fmt.Sprintf("%s self + %s,", mixinSignature, mixinBody)
		i.writeLine(line)
	}
}

func (e *emitVisitor) visitTypeAlias(p *property) {

	i := indentWriter{}
	e.indentWriters[p] = &i

	var path kubespec.DefinitionName
	if p.ref != nil {
		path = *p.ref.Name()
	} else {
		path = *p.itemTypes.Ref.Name()
	}
	parsedPath := path.Parse()
	if parsedPath.Version == nil {
		log.Printf("Could not emit type alias for '%s'\n", path)
		return
	}

	// Chop the `Type` off the end of the type alias name, rewrite the
	// "base" of the type alias, and then append `Type` to the end
	// again.
	//
	// Why: the desired behavior is for a rewrite rule to apply to both
	// a method and its type alias. For example, if we specify that
	// `scaleIO` should be rewritten `scaleIo`, then we'd like the type
	// alias to be emitted as `scaleIoType`, not `scaleIOType`,
	// automatically, so that the user doesn't have to specify another,
	// separate rule for the type alias itself.
	k8sVersion := p.root().spec.Info.Version
	trimmedName := kubespec.PropertyName(strings.TrimSuffix(string(p.name), "Type"))
	typeName := jsonnet.RewriteAsIdentifier(k8sVersion, trimmedName) + "Type"

	var group kubespec.GroupName
	if parsedPath.Group == nil {
		group = "core"
	} else {
		group = *parsedPath.Group
	}

	id := jsonnet.RewriteAsIdentifier(k8sVersion, parsedPath.Kind)
	line := fmt.Sprintf(
		"%s:: hidden.%s.%s.%s,",
		typeName, group, parsedPath.Version, id)

	i.writeLine(line)
}

func (e *emitVisitor) visitRefProperty(p *property, parentMixinName *string) {

	i := indentWriter{}
	e.indentWriters[p] = &i

	k8sVersion := p.root().spec.Info.Version
	setterFunctionName := jsonnet.RewriteAsIdentifier(k8sVersion, p.name).ToSetterID()
	fieldName := jsonnet.RewriteAsFieldKey(p.name)
	paramName := jsonnet.RewriteAsFuncParam(k8sVersion, p.name)
	setterSignature := fmt.Sprintf("%s(%s)::", setterFunctionName, paramName)

	var body string
	if parentMixinName == nil {
		body = fmt.Sprintf("{%s: %s}", fieldName, paramName)
	} else {
		body = fmt.Sprintf("%s({%s: %s})", *parentMixinName, fieldName, paramName)
	}
	line := fmt.Sprintf("%s %s,", setterSignature, body)

	i.insert(*e.indentWriters[&p.comments])
	i.writeLine(line)
}

func (e *emitVisitor) visitComments(cs *comments) {

	i := indentWriter{}
	e.indentWriters[cs] = &i

	for _, comment := range *cs {
		if comment == "" {
			// Don't create trailing space if comment is empty.
			i.writeLine("//")
		} else {
			i.writeLine(fmt.Sprintf("// %s", comment))
		}
	}
}
